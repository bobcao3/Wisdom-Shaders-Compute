#include "/libs/compat.glsl"

layout (local_size_x = 20, local_size_y = 20) in;

const vec2 workGroupsRender = vec2(1.0f, 1.0f);

uniform sampler2D colortex4;
uniform sampler2D colortex5;
uniform sampler2D colortex6;
uniform sampler2D colortex7;
uniform sampler2D colortex8;
uniform sampler2D depthtex0;

layout (r11f_g11f_b10f) uniform image2D colorimg5;

float16_t gaussian[] = float16_t[] (
    0.08650569214819082, 0.1137066467902003, 0.13397671175015194, 0.14150674744095673, 0.13397671175015194, 0.1137066467902003, 0.08650569214819082
);

uniform float viewWidth;
uniform float viewHeight;

const int radius = 3;
const int diameter = radius * 2;

int getIndex(ivec2 uv)
{
    return uv.y * int(gl_WorkGroupSize.x + diameter) + uv.x;
}

shared f16vec3 lds_normals[(gl_WorkGroupSize.x + diameter) * (gl_WorkGroupSize.y + diameter)];
shared f16vec3 lds_colors[(gl_WorkGroupSize.x + diameter) * (gl_WorkGroupSize.y + diameter)];
shared f16vec3 lds_albedo[(gl_WorkGroupSize.x + diameter) * (gl_WorkGroupSize.y + diameter)];
shared float lds_depth[(gl_WorkGroupSize.x + diameter) * (gl_WorkGroupSize.y + diameter)];
shared bool lds_valid[(gl_WorkGroupSize.x + diameter) * (gl_WorkGroupSize.y + diameter)];

uniform float near;
uniform float far;

float linearizeDepth(in float d) {
    return (2 * near) / (far + near - (d * 2.0 - 1.0) * (far - near));
}

void load(ivec2 local_xy, ivec2 iuv)
{
    ivec2 sample_uv = clamp(iuv, ivec2(0), ivec2(floor(viewWidth) - 1, floor(viewHeight) - 1));

    f16vec3 sample_normal = f16vec3(texelFetch(colortex7, sample_uv * 2, 0).rgb);
    f16vec3 sample_albedo = f16vec3(texelFetch(colortex6, sample_uv * 2, 0).rgb);
    f16vec3 sample_color = f16vec3(imageLoad(colorimg5, sample_uv).rgb);

    lds_albedo[getIndex(local_xy + 2)] = sample_albedo;
    lds_colors[getIndex(local_xy + 2)] = sample_color;
    lds_normals[getIndex(local_xy + 2)] = sample_normal;

    float depth = texelFetch(colortex4, sample_uv, 0).r;
    lds_valid[getIndex(local_xy + 2)] = depth < 1.0 && sample_uv == iuv;
    lds_depth[getIndex(local_xy + 2)] = linearizeDepth(depth);
}

void main()
{
    ivec2 group_base = ivec2((gl_WorkGroupSize.xy * STRIDE) * (gl_WorkGroupID.xy / STRIDE) + (gl_WorkGroupID.xy % STRIDE));
    ivec2 iuv = group_base + ivec2(gl_LocalInvocationID.xy * STRIDE);
    ivec2 local_id = ivec2(gl_LocalInvocationID.xy) + radius;

    // Load the padding
    {
        int index = int(gl_LocalInvocationIndex);
        const int padded_width = int(gl_WorkGroupSize.x + diameter);
        const int local_size = int(gl_WorkGroupSize.x * gl_WorkGroupSize.y);
        const int block_size = int((gl_WorkGroupSize.x + diameter) * (gl_WorkGroupSize.y + diameter));

        while (index < block_size)
        {
            ivec2 local_xy = ivec2((index % padded_width) - radius, (index / padded_width) - radius);
            ivec2 pad_uv = group_base + local_xy * STRIDE;
            load(local_xy, pad_uv);

            index += local_size;
        }
    }

    memoryBarrierShared();
    barrier();

    if (!lds_valid[getIndex(local_id)]) return;

    f16vec3 normal = lds_normals[getIndex(local_id)];

    f16vec3 color = f16vec3(0.0);
    float16_t total_var = 0.0;
    float16_t weight = 0.0001;

    f16vec3 center_color = lds_colors[getIndex(local_id)];

    float16_t center_luma = dot(center_color, f16vec3(0.2126, 0.7152, 0.0722));

    float center_depth = lds_depth[getIndex(local_id)];

    f16vec3 center_albedo = lds_albedo[getIndex(local_id)];

    // Filter
    for (int i = -radius; i <= radius; i++)
    {
        for (int j = -radius; j <= radius; j++)
        {
            ivec2 offset = ivec2(i, j);
            f16vec3 sample_color = lds_colors[getIndex(local_id + offset)];

            if (isnan(sample_color.r) || !lds_valid[getIndex(local_id + offset)]) continue;

            f16vec3 sample_normal = lds_normals[getIndex(local_id + offset)];
            f16vec3 sample_albedo = lds_albedo[getIndex(local_id + offset)] - center_albedo;
            float16_t color_diff = abs(dot(sample_color, f16vec3(0.2126, 0.7152, 0.0722)) - center_luma);
            float sample_depth = lds_depth[getIndex(local_id + offset)];

            float16_t sample_weight = gaussian[i + radius] * gaussian[j + radius];
            sample_weight *= pow(max(float16_t(0.0), dot(normal, sample_normal)), float16_t(128.0));
            sample_weight *= exp(-dot(sample_albedo, sample_albedo) * 20.0);
            sample_weight *= exp(float16_t(-abs(sample_depth - center_depth) / max(0.03, center_depth) * 8.0));

            color += sample_color * sample_weight;
            weight += sample_weight;
        }
    }

    imageStore(colorimg5, iuv, vec4(color / weight, 0.0));

}